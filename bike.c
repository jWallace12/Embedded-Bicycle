/*
 David Nachmonson and Jonah Wallace
 * Bike
 * CSCI_497I
*/

#include "lpc1114.h"
#include "bike.h"

#define AA   (1<<2)
#define SI   (1<<3)
#define STO  (1<<4)
#define STA  (1<<5)
#define I2EN (1<<6)
#define DISPLAY_WIDTH 128
#define DISPLAY_HEIGHT 8
#define FONT_WIDTH 6
#define PIXELS_FROM_DISPLAY_TOP 16
#define PIXELS_PER_BYTE 8
#define PIXELS_TO_LEFT_DISPLAY 32
#define PIXELS_TO_MID_DISPLAY_LEFT 60
#define PIXELS_TO_MID_DISPLAY_RIGHT 68
#define PIXELS_TO_RIGHT_DISPLAY 96

int i = 0;
int display_row = 0;
int display_column = 0;
unsigned backGearCurrPosition = 0;
unsigned backGearNextPosition  = 0;
unsigned overallGear = 6;
unsigned magnetsPassed = 0;
unsigned prevVoltage = 0;
unsigned cadenceInit = 0;
enum direction{WEST, SOUTH, EAST, NORTH};
enum direction currDirection;
unsigned servoValues[3] = {17500, 18000, 18500};
unsigned int stepperValues[6] = {300, 1050, 1500, 1950, 2500, 3000};
volatile unsigned char lcd_display[DISPLAY_HEIGHT][DISPLAY_WIDTH];
const unsigned stepperMovements[4][4] = {

  /* A -A  B -B */
  {~0, 0, 0, 0}, // WEST
  {0, 0, ~0, 0}, // SOUTH
  {0, ~0, 0, 0}, // EAST
  {0, 0, 0, ~0}  // NORTH
};

/* Front Gears */
unsigned frontGears[] = {
  0, 0, 1, 0, 0, 1, 2, 0, 1,
  0, 2, 1, 1, 2, 2, 1, 2, 2
};

/* Back Gears */
unsigned backGears[] = {
  5, 4, 5, 3, 2, 4, 5, 1, 3,
  0, 4, 2, 1, 3, 2, 0, 1, 0
};


const char top_6x14[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  32 space */
  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, /*  33 exclam */
  0x00, 0x00, 0x1e, 0x00, 0x1e, 0x00, /*  34 quotedbl */
  0x00, 0x20, 0xfc, 0x20, 0xfc, 0x20, /*  35 numbersign */
  0x30, 0x48, 0x88, 0xfc, 0x88, 0x30, /*  36 dollar */
  0x18, 0x24, 0xa4, 0x78, 0x10, 0x0c, /*  37 percent */
  0x00, 0xb8, 0xc4, 0x44, 0x38, 0x80, /*  38 ampersand */
  0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, /*  39 quotesingle */
  0x00, 0x00, 0xe0, 0x18, 0x04, 0x02, /*  40 parenleft */
  0x00, 0x02, 0x04, 0x18, 0xe0, 0x00, /*  41 parenright */
  0x00, 0x20, 0x40, 0xf0, 0x40, 0x20, /*  42 asterisk */
  0x00, 0x80, 0x80, 0xf0, 0x80, 0x80, /*  43 plus */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  44 comma */
  0x00, 0x80, 0x80, 0x80, 0x80, 0x80, /*  45 hyphen */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  46 period */
  0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, /*  47 slash */
  0xf0, 0x08, 0x04, 0x04, 0x08, 0xf0, /*  48 zero */
  0x00, 0x10, 0x08, 0xfc, 0x00, 0x00, /*  49 one */
  0x18, 0x04, 0x04, 0x04, 0xc4, 0x38, /*  50 two */
  0x04, 0x04, 0x44, 0x64, 0x54, 0x8c, /*  51 three */
  0x00, 0xc0, 0x30, 0x08, 0xfc, 0x00, /*  52 four */
  0x7c, 0x24, 0x24, 0x24, 0x24, 0xc4, /*  53 five */
  0xf0, 0x88, 0x44, 0x44, 0x44, 0x80, /*  54 six */
  0x04, 0x04, 0x04, 0xc4, 0x34, 0x0c, /*  55 seven */
  0x18, 0xa4, 0x44, 0x44, 0xa4, 0x18, /*  56 eight */
  0x78, 0x84, 0x84, 0x84, 0x44, 0xf8, /*  57 nine */
  0x00, 0x00, 0x20, 0x70, 0x20, 0x00, /*  58 colon */
  0x00, 0x00, 0x60, 0x60, 0x00, 0x00, /*  59 semicolon */
  0x00, 0x80, 0x40, 0x20, 0x10, 0x08, /*  60 less */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /*  61 equal */
  0x00, 0x08, 0x10, 0x20, 0x40, 0x80, /*  62 greater */
  0x18, 0x04, 0x04, 0xc4, 0x24, 0x18, /*  63 question */
  0xf0, 0x08, 0xe4, 0x14, 0x14, 0xf8, /*  64 at */
  0xf0, 0x88, 0x84, 0x84, 0x88, 0xf0, /*  65 A */
  0xfc, 0x44, 0x44, 0x44, 0xa8, 0x10, /*  66 B */
  0xf8, 0x04, 0x04, 0x04, 0x04, 0x18, /*  67 C */
  0xfc, 0x04, 0x04, 0x04, 0x08, 0xf0, /*  68 D */
  0xfc, 0x44, 0x44, 0x44, 0x04, 0x04, /*  69 E */
  0xfc, 0x44, 0x44, 0x44, 0x04, 0x04, /*  70 F */
  0xf8, 0x04, 0x04, 0x84, 0x84, 0x98, /*  71 G */
  0xfc, 0x40, 0x40, 0x40, 0x40, 0xfc, /*  72 H */
  0x00, 0x04, 0x04, 0xfc, 0x04, 0x04, /*  73 I */
  0x00, 0x00, 0x00, 0x04, 0xfc, 0x04, /*  74 J */
  0xfc, 0x40, 0xa0, 0x10, 0x08, 0x04, /*  75 K */
  0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, /*  76 L */
  0xfc, 0x18, 0x60, 0x60, 0x18, 0xfc, /*  77 M */
  0xfc, 0x30, 0x40, 0x80, 0x00, 0xfc, /*  78 N */
  0xf8, 0x04, 0x04, 0x04, 0x04, 0xf8, /*  79 O */
  0xfc, 0x84, 0x84, 0x84, 0x84, 0x78, /*  80 P */
  0xf8, 0x04, 0x04, 0x04, 0x04, 0xf8, /*  81 Q */
  0xfc, 0x84, 0x84, 0x84, 0x84, 0x78, /*  82 R */
  0x38, 0x44, 0x44, 0x84, 0x84, 0x18, /*  83 S */
  0x04, 0x04, 0x04, 0xfc, 0x04, 0x04, /*  84 T */
  0xfc, 0x00, 0x00, 0x00, 0x00, 0xfc, /*  85 U */
  0x3c, 0xc0, 0x00, 0x00, 0xc0, 0x3c, /*  86 V */
  0x00, 0xfc, 0x00, 0x00, 0x00, 0xfc, /*  87 W */
  0x0c, 0x30, 0xc0, 0xc0, 0x30, 0x0c, /*  88 X */
  0x00, 0x1c, 0x60, 0x80, 0x60, 0x1c, /*  89 Y */
  0x04, 0x04, 0x84, 0x64, 0x14, 0x0c, /*  90 Z */
  0x00, 0x00, 0xfe, 0x02, 0x02, 0x02, /*  91 bracketleft */
  0x06, 0x18, 0xe0, 0x00, 0x00, 0x00, /*  92 backslash */
  0x00, 0x02, 0x02, 0x02, 0xfe, 0x00, /*  93 bracketright */
  0x08, 0x04, 0x02, 0x02, 0x04, 0x08, /*  94 asciicircum */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  95 underscore */
  0x00, 0x00, 0x02, 0x04, 0x08, 0x00, /*  96 grave */
  0x40, 0x20, 0x20, 0x20, 0x20, 0xc0, /*  97 a */
  0xfc, 0x40, 0x20, 0x20, 0x20, 0xc0, /*  98 b */
  0xc0, 0x20, 0x20, 0x20, 0x20, 0x40, /*  99 c */
  0xc0, 0x20, 0x20, 0x20, 0x40, 0xfc, /* 100 d */
  0xc0, 0x20, 0x20, 0x20, 0x20, 0xc0, /* 101 e */
  0x40, 0x40, 0xf8, 0x44, 0x44, 0x08, /* 102 f */
  0xc0, 0x20, 0x20, 0x20, 0xc0, 0x20, /* 103 g */
  0xfc, 0x40, 0x20, 0x20, 0x20, 0xc0, /* 104 h */
  0x00, 0x00, 0x20, 0xec, 0x00, 0x00,/* 105 i */
  0x00, 0x00, 0x00, 0x00, 0x20, 0xec, /* 106 j */
  0xfc, 0x00, 0x80, 0x40, 0x20, 0x00, /* 107 k */
  0x00, 0x00, 0x04, 0xfc, 0x00, 0x00, /* 108 l */
  0x00, 0xe0, 0x20, 0xc0, 0x20, 0xc0, /* 109 m */
  0xe0, 0x40, 0x20, 0x20, 0x20, 0xc0, /* 110 n */
  0xc0, 0x20, 0x20, 0x20, 0x20, 0xc0, /* 111 o */
  0xe0, 0x40, 0x20, 0x20, 0x20, 0xc0, /* 112 p */
  0xc0, 0x20, 0x20, 0x20, 0x40, 0xe0, /* 113 q */
  0xe0, 0x40, 0x20, 0x20, 0x20, 0xc0, /* 114 r */
  0x40, 0xa0, 0x20, 0x20, 0x20, 0x40, /* 115 s */
  0x20, 0x20, 0xfc, 0x20, 0x20, 0x00, /* 116 t */
  0xe0, 0x00, 0x00, 0x00, 0x00, 0xe0, /* 117 u */
  0x00, 0xe0, 0x00, 0x00, 0x00, 0xe0, /* 118 v */
  0x00, 0xe0, 0x00, 0x80, 0x00, 0xe0, /* 119 w */
  0x60, 0x80, 0x00, 0x00, 0x80, 0x60, /* 120 x */
  0xe0, 0x00, 0x00, 0x00, 0x00, 0xe0, /* 121 y */
  0x20, 0x20, 0x20, 0xa0, 0x60, 0x20, /* 122 z */
  0x00, 0x00, 0x80, 0x7c, 0x02, 0x02, /* 123 braceleft */
  0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, /* 124 bar */
  0x00, 0x02, 0x02, 0x7c, 0x80, 0x00, /* 125 braceright */
  0x0c, 0x02, 0x04, 0x08, 0x10, 0x0c /* 126 asciitilde */
};
const char bot_6x14[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  32 space */
  0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, /*  33 exclam */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  34 quotedbl */
  0x00, 0x01, 0x0f, 0x01, 0x0f, 0x01, /*  35 numbersign */
  0x06, 0x08, 0x08, 0x1f, 0x08, 0x07, /*  36 dollar */
  0x0c, 0x02, 0x07, 0x09, 0x09, 0x06, /*  37 percent */
  0x07, 0x08, 0x08, 0x05, 0x06, 0x09, /*  38 ampersand */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  39 quotesingle */
  0x00, 0x00, 0x03, 0x0c, 0x10, 0x20, /*  40 parenleft */
  0x00, 0x20, 0x10, 0x0c, 0x03, 0x00, /*  41 parenright */
  0x00, 0x02, 0x01, 0x07, 0x01, 0x02, /*  42 asterisk */
  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, /*  43 plus */
  0x00, 0x00, 0x24, 0x1c, 0x00, 0x00, /*  44 comma */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  45 hyphen */
  0x00, 0x00, 0x08, 0x1c, 0x08, 0x00, /*  46 period */
  0x30, 0x0c, 0x03, 0x00, 0x00, 0x00, /*  47 slash */
  0x03, 0x04, 0x08, 0x08, 0x04, 0x03, /*  48 zero */
  0x00, 0x08, 0x08, 0x0f, 0x08, 0x08, /*  49 one */
  0x08, 0x0c, 0x0a, 0x09, 0x08, 0x08, /*  50 two */
  0x06, 0x08, 0x08, 0x08, 0x08, 0x07, /*  51 three */
  0x03, 0x02, 0x02, 0x02, 0x0f, 0x02, /*  52 four */
  0x06, 0x08, 0x08, 0x08, 0x08, 0x07, /*  53 five */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x07, /*  54 six */
  0x00, 0x0c, 0x03, 0x00, 0x00, 0x00, /*  55 seven */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x07, /*  56 eight */
  0x06, 0x08, 0x08, 0x08, 0x04, 0x03, /*  57 nine */
  0x00, 0x00, 0x04, 0x0e, 0x04, 0x00, /*  58 colon */
  0x00, 0x00, 0x12, 0x0e, 0x00, 0x00, /*  59 semicolon */
  0x00, 0x00, 0x01, 0x02, 0x04, 0x08, /*  60 less */
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, /*  61 equal */
  0x00, 0x08, 0x04, 0x02, 0x01, 0x00, /*  62 greater */
  0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, /*  63 question */
  0x03, 0x04, 0x09, 0x0a, 0x0a, 0x0b, /*  64 at */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, /*  65 A */
  0x0f, 0x08, 0x08, 0x08, 0x04, 0x03, /*  66 B */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x06, /*  67 C */
  0x0f, 0x08, 0x08, 0x08, 0x04, 0x03, /*  68 D */
  0x0f, 0x08, 0x08, 0x08, 0x08, 0x08, /*  69 E */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, /*  70 F */
  0x07, 0x08, 0x08, 0x08, 0x04, 0x0f, /*  71 G */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, /*  72 H */
  0x00, 0x08, 0x08, 0x0f, 0x08, 0x08, /*  73 I */
  0x06, 0x08, 0x08, 0x08, 0x07, 0x00, /*  74 J */
  0x0f, 0x00, 0x00, 0x01, 0x02, 0x0c, /*  75 K */
  0x0f, 0x08, 0x08, 0x08, 0x08, 0x08, /*  76 L */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, /*  77 M */
  0x0f, 0x00, 0x00, 0x00, 0x03, 0x0f, /*  78 N */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x07, /*  79 O */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, /*  80 P */
  0x07, 0x09, 0x09, 0x0a, 0x1c, 0x27, /*  81 Q */
  0x0f, 0x00, 0x00, 0x01, 0x02, 0x0c, /*  82 R */
  0x06, 0x08, 0x08, 0x08, 0x08, 0x07, /*  83 S */
  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, /*  84 T */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x07, /*  85 U */
  0x00, 0x01, 0x0e, 0x0e, 0x01, 0x00, /*  86 V */
  0x00, 0x07, 0x08, 0x07, 0x08, 0x07, /*  87 W */
  0x0c, 0x03, 0x00, 0x00, 0x03, 0x0c, /*  88 X */
  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, /*  89 Y */
  0x0c, 0x0b, 0x08, 0x08, 0x08, 0x08, /*  90 Z */
  0x00, 0x00, 0x3f, 0x20, 0x20, 0x20, /*  91 bracketleft */
  0x00, 0x00, 0x00, 0x03, 0x0c, 0x30, /*  92 backslash */
  0x00, 0x20, 0x20, 0x20, 0x3f, 0x00, /*  93 bracketright */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  94 asciicircum */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /*  95 underscore */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  96 grave */
  0x06, 0x09, 0x09, 0x09, 0x09, 0x0f, /*  97 a */
  0x0f, 0x04, 0x08, 0x08, 0x08, 0x07, /*  98 b */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x04, /*  99 c */
  0x07, 0x08, 0x08, 0x08, 0x04, 0x0f, /* 100 d */
  0x07, 0x09, 0x09, 0x09, 0x09, 0x05, /* 101 e */
  0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, /* 102 f */
  0x19, 0x26, 0x2a, 0x2a, 0x29, 0x10, /* 103 g */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, /* 104 h */
  0x00, 0x08, 0x08, 0x0f, 0x08, 0x08, /* 105 i */
  0x00, 0x18, 0x20, 0x20, 0x20, 0x1f, /* 106 j */
  0x0f, 0x01, 0x01, 0x02, 0x04, 0x08, /* 107 k */
  0x00, 0x08, 0x08, 0x0f, 0x08, 0x08, /* 108 l */
  0x00, 0x0f, 0x00, 0x07, 0x00, 0x0f, /* 109 m */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, /* 110 n */
  0x07, 0x08, 0x08, 0x08, 0x08, 0x07, /* 111 o */
  0x3f, 0x04, 0x08, 0x08, 0x08, 0x07, /* 112 p */
  0x07, 0x08, 0x08, 0x08, 0x04, 0x3f, /* 113 q */
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, /* 114 r */
  0x04, 0x08, 0x09, 0x09, 0x0a, 0x04, /* 115 s */
  0x00, 0x00, 0x07, 0x08, 0x08, 0x04, /* 116 t */
  0x07, 0x08, 0x08, 0x08, 0x04, 0x0f, /* 117 u */
  0x00, 0x00, 0x03, 0x0c, 0x03, 0x00, /* 118 v */
  0x00, 0x07, 0x08, 0x07, 0x08, 0x07, /* 119 w */
  0x0c, 0x02, 0x01, 0x01, 0x02, 0x0c, /* 120 x */
  0x13, 0x24, 0x24, 0x24, 0x22, 0x1f, /* 121 y */
  0x08, 0x0c, 0x0b, 0x08, 0x08, 0x08, /* 122 z */
  0x00, 0x00, 0x00, 0x1f, 0x20, 0x20, /* 123 braceleft */
  0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, /* 124 bar */
  0x00, 0x20, 0x20, 0x1f, 0x00, 0x00, /* 125 braceright */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /* 126 asciitilde */
};


const
unsigned char buffer[] = {0x78,  /* Device address    */
  0x80, 0xA8, 0x80, 0x3f, /* MUX Ratio         */
  0x80, 0xD3, 0x80, 0x00, /* Display Offset    */
  0x80, 0x40,             /* Start Line        */

  /* These  make the yellow bar the top.       */
  0x80, 0xA1,             /* Segment Remap     */
  0x80, 0xC8,             /* Scan Direction    */


  0x80, 0xDA, 0x80, 0x02, /* Hardware COM Pins */
  0x80, 0x81, 0x80, 0x7F, /* Contrast          */
  0x80, 0xA4,             /* Display ON        */
  0x80, 0xA6,             /* Normal (A7 invert)*/
  0x80, 0xF5, 0x80, 0x80, /* Oscillator Freq.  */
  0x80, 0x8D, 0x80, 0x14, /* OLED brightness   */
  0x80, 0xAf,             /* OLED ON (AE off)  */

  /* Set column position to 0                  */
  0x80, 0x21, 0x80, 0x00, 0x80, 0x7F,

  /* Set page (row) positing to 0              */
  0x80, 0x22, 0x80, 0x00, 0x80, 0x07,

  /* addressing mode (left->right, top->bottom)*/
  0x80, 0x20, 0x80, 0x00,

  /* Data */

  0x40
};


void setup() {

  /* TIMER/DEVICE SETUP */
  SYSCON.SYSAHBCLKCTRL.CT16B0 = 1;
  SYSCON.SYSAHBCLKCTRL.CT16B1 = 1;
  SYSCON.SYSAHBCLKCTRL.CT32B0 = 1;
  SYSCON.SYSAHBCLKCTRL.CT32B1 = 1;
  SYSCON.SYSAHBCLKCTRL.IOCON  = 1;
  SYSCON.SYSAHBCLKCTRL.ADC    = 1;
  SYSCON.SYSAHBCLKCTRL.I2C    = 1;
  SYSCON.PRESETCTRL.I2C_RST_N = 1;
  SYSCON.PDRUNCFG             = 0<<4;

  IOCON.R_PIO0_11.FUNC        = 2;
  IOCON.R_PIO0_11.ADMODE      = 0;
  IOCON.PIO0_9.FUNC           = 2;
  IOCON.PIO1_9.FUNC 	        = 1;
  IOCON.PIO1_6	      	      = 1<<2;

  IOCON.PIO0_5.FUNC           = 1;
  IOCON.PIO0_5.I2CMODE        = 0;

  IOCON.PIO0_4.FUNC           = 1;
  IOCON.PIO0_4.I2CMODE        = 0;


  /* CADENCE TIMER */
  TMR16B0.PR		              = 1000;
  TMR16B0.MR1		              = 48000;
  TMR16B0.MCR.MR1R	          = 1;
  TMR16B0.PWMC.PWMEN0	        = 1;
  TMR16B0.TC		              = 0;
  TMR16B0.PC		              = 0;
  TMR16B0.TCR.CEn	            = 1;

  /* SERVO TIMER */
  TMR16B1.PR		              = 48;
  TMR16B1.MR1		              = 20000;
  TMR16B1.MR0                 = 18500;
  TMR16B1.MCR.MR1R	          = 1;
  TMR16B1.PWMC.PWMEN0	        = 1;
  TMR16B1.TC		              = 0;
  TMR16B1.PC		              = 0;
  TMR16B1.TCR.CEn	            = 1;

  /* STEPPER TIMER */
  TMR32B0.PR		              = 48;
  TMR32B0.MR0		              = 1000;
  TMR32B0.MR1		              = 5000;
  TMR32B0.MCR.MR1R	          = 1;
  TMR32B0.TC		              = 0;
  TMR32B0.PC		              = 0;
  TMR32B0.TCR.CEn	            = 1;

  /* SWITCH TIMER */
  TMR32B1.PR		              = 48;
  TMR32B1.MR0		              = 1000;
  TMR32B1.MR1		              = 5000;
  TMR32B1.MCR.MR0I	          = 1;
  TMR32B1.MCR.MR1I	          = 1;
  TMR32B1.MCR.MR1R	          = 1;
  TMR32B1.TC		              = 0;
  TMR32B1.PC		              = 0;
  TMR32B1.TCR.CEn	            = 1;

  /* STEPPER PINS */
  GPIO0.DIR.PIN1	            = 1;
  GPIO0.DIR.PIN2	            = 1;
  GPIO0.DIR.PIN3	            = 1;
  GPIO0.DIR.PIN8	            = 1;

  /* SWITCH INPUT */
  GPIO0.DIR.PIN7	            = 0;

  /* ADC CONVERTER */
  AD0.CR.SEL		              = 1;
  AD0.CR.BURST                = 0;
  AD0.CR.CLKDIV		            = 10;
  AD0.CR.CLKS 		            = 0;
  AD0.INTEN.ADINTEN           = 1;

  /* DISPLAY */
  I2C0.SCLH                  = 240;
  I2C0.SCLL                  = 240;
  I2C0.CONSET                = I2EN;

  ISER                      |= 1<<15;
  ISER                      |= 1<<16;
  ISER                      |= 1<<17;
  ISER                      |= 1<<18;
  ISER                      |= 1<<19;
  ISER                      |= 1<<24;

  currDirection             = WEST;
  AD0.CR.START              = 1;
  clearDisplay();
  setupDisplay();
  I2C0.CONSET               = STA;
}

/* Interrupt 15
* Handle setting up the I2C display
*/
void IRQ15() {
  switch(I2C0.STAT>>3) {
    case 1: /* START condition has been transmitted. */
    case 2: /* Repeated START condition has been transmitted. */
    I2C0.DAT = buffer[i] + 0;
    ++i;
    I2C0.CONCLR = STA | AA | SI;
    break;

    case 3: /* SLA+W has been transmitted; ACK has been received. */
    case 5: /* Data byte in DAT has been transmitted; ACK has been received. */

    if (i < (sizeof(buffer)/sizeof(buffer[0]))) {
      I2C0.DAT = buffer[i];
      ++i;
      I2C0.CONCLR = STA | STO | AA | SI;
    } else if(display_row < DISPLAY_HEIGHT) {
      I2C0.DAT = lcd_display[display_row][display_column];
      display_column++;
      if (display_column == DISPLAY_WIDTH) {
        display_row++;
        display_column = 0;
      }
      I2C0.CONCLR = STA | STO | AA | SI;
    } else {
      display_row    = 0;
      display_column = 0;
      i = 0;
      I2C0.CONSET = STO;
      I2C0.CONCLR = STA | AA | SI;
    }
    break;

    case 4: /* SLA+W has been transmitted; NOT ACK has been received. */
    case 6: /* Data byte in DAT has been transmitted; NOT ACK has been received. */
    I2C0.CONSET = STO;
    I2C0.CONCLR = STA | AA | SI;
    break;

    case 7: /* Arbitration lost in SLA+R/W or Data bytes. */
    I2C0.CONCLR = STA | STO | AA | SI;
    break;
  }
}



/*
Interrupt 16
* Check how many times the magnet was sensed
* and change gear accordingly
*/

void IRQ16() {
  TMR16B0.IR.MR1 = 1;
  if (cadenceInit == 0) {
    cadenceInit = 1;
  } else {
    if ((magnetsPassed > 0) && (magnetsPassed < 3)) {
      if (overallGear != 0) {
        overallGear--;
        TMR16B1.MR0              = servoValues[frontGears[overallGear]];
        backGearNextPosition     = stepperValues[backGears[overallGear]];
        cadenceInit              = 0;
        TMR16B0.MCR.MR1I 	       = 0;
      }
    } else if (magnetsPassed > 6) {
      if (overallGear != 17) {
        overallGear++;
        TMR16B1.MR0              = servoValues[frontGears[overallGear]];
        backGearNextPosition     = stepperValues[backGears[overallGear]];
        cadenceInit              = 0;
        TMR16B0.MCR.MR1I 	       = 0;
      }
    }
  }
  magnetsPassed = 0;
}


/* Interrupt 18
* Stop or move the stepper motor,
* and update I2C display
*/
void IRQ18() {
  if (TMR32B0.IR.MR0 == 1) {
    TMR32B0.IR.MR0 = 1;
    GPIO0.DATA[1<<1] = 0;
    GPIO0.DATA[1<<2] = 0;
    GPIO0.DATA[1<<3] = 0;
    GPIO0.DATA[1<<8] = 0;
  } else if (TMR32B0.IR.MR1 == 1) {
    TMR32B0.IR.MR1 = 1;
    if (backGearCurrPosition < backGearNextPosition) {
      moveStepperUp(currDirection);
      backGearCurrPosition++;
    } else if (backGearCurrPosition > backGearNextPosition) {
      moveStepperDown(currDirection);
      backGearCurrPosition--;
    } else {
      TMR16B0.MCR.MR1I 	      = 1;
      writeDisplay(overallGear+1, frontGears[overallGear]+1, backGears[overallGear]+1);
      I2C0.CONSET             = STA;
    }
  }
}

/* Interrupt 19
* Move the stepper until it
* hits the switch
*/
void IRQ19() {
  if (TMR32B1.IR.MR0 == 1) {
    TMR32B1.IR.MR0 = 1;
    GPIO0.DATA[1<<1] = 0;
    GPIO0.DATA[1<<2] = 0;
    GPIO0.DATA[1<<3] = 0;
    GPIO0.DATA[1<<8] = 0;
  } else if (TMR32B1.IR.MR1 == 1) {
    TMR32B1.IR.MR1 = 1;
    if (GPIO0.DATA[1<<7] != 0) {
      moveStepperDown(currDirection);
    } else {
      TMR32B1.MCR.MR0I	      = 0;
      TMR32B1.MCR.MR1I	      = 0;
      TMR16B1.MR0             = servoValues[frontGears[overallGear]];
      backGearNextPosition     = stepperValues[backGears[overallGear]];
      TMR32B0.MCR.MR0I	      = 1;
      TMR32B0.MCR.MR1I	      = 1;
    }
  }
}

/* Interrupt 24
* Convert AD0 channel 0 sample to check
* if sample changed from low to high
* If so, record that a magnet passed by
*/
void IRQ24() {
  unsigned voltage = AD0.DR0.V_VREF;
  if (prevVoltage > 700) {
    if (voltage < 200) {
      magnetsPassed++;
    }
  }
  prevVoltage = voltage;
  AD0.CR.START = 1;
}

/* Move Stepper Down */
void moveStepperDown(unsigned index) {
  GPIO0.DATA[1<<1] = stepperMovements[index][0];
  GPIO0.DATA[1<<2] = stepperMovements[index][1];
  GPIO0.DATA[1<<3] = stepperMovements[index][2];
  GPIO0.DATA[1<<8] = stepperMovements[index][3];
  if (currDirection == 3) {
    currDirection = WEST;
  } else {
    currDirection++;
  }

}

/* Move Stepper Up */
void moveStepperUp(unsigned index) {
  GPIO0.DATA[1<<1] = stepperMovements[index][0];
  GPIO0.DATA[1<<2] = stepperMovements[index][1];
  GPIO0.DATA[1<<3] = stepperMovements[index][2];
  GPIO0.DATA[1<<8] = stepperMovements[index][3];
  if (currDirection == 0) {
    currDirection = NORTH;
  } else {
    currDirection--;
  }
}

/* Clear Display */
void clearDisplay() {
  for (int x = 0; x < DISPLAY_HEIGHT; x++) {
    for (int y = 0; y < DISPLAY_WIDTH; y++) {
      lcd_display[x][y] = 0;
    }
  }
}

/* Setup Display */
void setupDisplay() {

  lcd_display[0][30] = 0x7F;
  lcd_display[0][31] = 0x09;
  lcd_display[0][32] = 0x09;
  lcd_display[0][33] = 0x01;
  lcd_display[0][34] = 0x01; // F

  lcd_display[0][51] = 0x3E;
  lcd_display[0][52] = 0x41;
  lcd_display[0][53] = 0x41;
  lcd_display[0][54] = 0x51;
  lcd_display[0][55] = 0x32; // G

  lcd_display[0][59] = 0x7F;
  lcd_display[0][60] = 0x49;
  lcd_display[0][61] = 0x49;
  lcd_display[0][62] = 0x49;
  lcd_display[0][63] = 0x41; // E

  lcd_display[0][67] = 0x7E;
  lcd_display[0][68] = 0x11;
  lcd_display[0][69] = 0x11;
  lcd_display[0][70] = 0x11;
  lcd_display[0][71] = 0x7E; // A

  lcd_display[0][75] = 0x7F;
  lcd_display[0][76] = 0x09;
  lcd_display[0][77] = 0x19;
  lcd_display[0][78] = 0x29;
  lcd_display[0][79] = 0x46; // R

  lcd_display[0][96]  = 0x7F;
  lcd_display[0][97]  = 0x09;
  lcd_display[0][98]  = 0x19;
  lcd_display[0][99]  = 0x29;
  lcd_display[0][100] = 0x46; // R
}

/* Write Character */
void writeCharacter(int asciiValue, int pixelsFromTop, int pixelsFromLeft){
  int startIndex = (asciiValue - (int) ' ') * 6;
  int lcdDisplayRowIndex = pixelsFromTop / PIXELS_PER_BYTE;
  for (int i = 0; i < FONT_WIDTH; i++) {
    lcd_display[lcdDisplayRowIndex][pixelsFromLeft + i] = top_6x14[startIndex + i];
    lcd_display[lcdDisplayRowIndex + 1][pixelsFromLeft + i] = bot_6x14[startIndex + i];
  }
}

/* Write Display */
void writeDisplay(unsigned speed, unsigned frontGear, unsigned backGear) {
  clearDisplay();
  setupDisplay();
  writeCharacter(frontGear + (int) '0',PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_LEFT_DISPLAY);
  writeCharacter(backGear + (int) '0', PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_RIGHT_DISPLAY);
  if (speed < 10) {
    writeCharacter(0 + (int) '0',PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_MID_DISPLAY_LEFT);
    writeCharacter(speed + (int) '0', PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_MID_DISPLAY_RIGHT);
  } else {
    writeCharacter(1 + (int) '0',PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_MID_DISPLAY_LEFT);
    writeCharacter(speed-10 + (int) '0', PIXELS_FROM_DISPLAY_TOP,PIXELS_TO_MID_DISPLAY_RIGHT);
  }
}
